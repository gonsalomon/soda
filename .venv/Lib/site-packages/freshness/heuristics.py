from __future__ import annotations

import numpy as np
import pandas as pd


def get_heuristic_scores(df: pd.DataFrame, utc_now: pd.Timestamp) -> dict:
    score_dict = {}

    # Check incrementality score whether the data is ordered
    incrementality_scores = [compute_incrementality_score(df[col_name]) for col_name in df.columns]
    incrementality_threshold = 0.7

    for col_name in df.columns:
        if max(incrementality_scores) > incrementality_threshold:
            series = df[col_name]
        else:
            series = df[col_name].sort_values()

        score_dict[col_name] = {
            "incrementality_score": compute_incrementality_score(series),
            "std_score": compute_std_score(series),
            "last_date_score": compute_last_date_score(series, utc_now),
            "not_null_score": compute_not_null_score(series),
            "col_name_score": compute_col_name_score(col_name),
        }

    return score_dict


def compute_col_name_score(col_name: str) -> float:
    weights = {
        "create": 1,
        "insert": 1,
        "generate": 1,
        "load": 1,
        "update": 0.6,
        "modify": 0.6,
        "modifi": 0.6,
    }

    # Lowercase chars
    col_name = col_name.lower()

    # Get score
    score = 0.0
    for key, value in weights.items():
        if key in col_name:
            score = max(score, value)
    return score


def compute_incrementality_score(series: pd.Series) -> float:
    diff_series = series.diff().dt.total_seconds().dropna()
    count_positives = np.sum(np.array(diff_series) > 0, axis=0)
    # subtract 1 since first row doesn't count
    return count_positives / (len(series) - 1)


def compute_not_null_score(series: pd.Series) -> float:
    count_not_nones = series.count()
    return count_not_nones / len(series)


def compute_std_score(series: pd.Series) -> float:
    """The lower std the better"""
    diff_series = series.diff().dt.total_seconds()
    std = diff_series.std()
    if std == 0:
        # Large enought number to handle 0 division error
        return 999999999
    else:
        return 1 / std


def compute_last_date_score(series: pd.Series, utc_now: pd.Timestamp) -> float | None:
    # Interpolate None values with forward fill
    interpolated_series = series.copy().ffill()
    del series
    if not interpolated_series.empty:
        delta = (interpolated_series.tail(1).item() - utc_now).total_seconds()
        return delta
    else:
        return None
