from __future__ import annotations

import logging
from typing import List

import numpy as np
import pandas as pd
from pydantic import BaseModel
from scipy.stats import rankdata

from freshness.heuristics import get_heuristic_scores


class FreshnessHeuristics(BaseModel):
    incrementality_score: float
    std_score: float
    last_date_score: float
    col_name_score: float
    suggestion_score: float


class FreshnessTimeThreshold(BaseModel):
    threshold_seconds: int
    soda_cl_threshold_str: str


class FreshnessColumnOutput(BaseModel):
    col_name: str
    heuristic_scores: FreshnessHeuristics
    threshold: FreshnessTimeThreshold
    rank: int


class FreshnessSuggestionOutput(BaseModel):
    freshness_attributes: List[FreshnessColumnOutput]


class FreshnessColumnDetector:
    def __init__(self):
        self._now_utc = pd.Timestamp.utcnow()

    def detect(self, df: pd.DataFrame) -> List[str]:
        """The method takes a pandas DataFrame having datetime columns
        and scores all columns based on a set of heuristics (see class methods) and orders the
        column names using the freshness column candidate scores.

        Args:
            df: Pandas dataframe having only datetime or date columns

        Returns:
            List[str]: List of candidate column names ordered from most likely to least likely.
        """
        # Preprocess
        df = self._convert_dates_to_utc(df)

        # Threshold in seconds
        suggested_freshness_thresholds = self._get_freshness_threshold(df)

        # Compute all heuristic scores for freshness
        scores_dict = get_heuristic_scores(df, self._now_utc)
        scores_df = pd.DataFrame(scores_dict).T

        # Prune columns based on some static rules
        scores_df = self._prune_null_columns(scores_df, "not_null_score")
        scores_df = scores_df.drop("not_null_score", axis=1)

        scores_df = self._prune_future_dates(scores_df, "last_date_score")

        # Rank all scores to find the most likely freshness column
        ranked_df = scores_df.apply(lambda col: rankdata(col, method="dense"))

        # Change the weight of the scores and recompute
        weights_dict = {
            "incrementality_score": 0.25,
            "std_score": 0.25,
            "last_date_score": 0.25,
            "col_name_score": 0.25,
        }
        ranked_df["suggestion_score"] = self._compute_final_weighted_score(ranked_df, weights_dict)

        # sort rank based on most likey to less
        ranked_df = ranked_df.sort_values("suggestion_score", ascending=False)
        scores_df = pd.merge(
            ranked_df["suggestion_score"], scores_df, left_index=True, right_index=True
        )
        scores_df["rank"] = np.arange(scores_df.shape[0])
        logging.debug(scores_df)
        logging.debug(ranked_df)
        del ranked_df

        suggestion_scores_dict = scores_df.T.to_dict()
        freshness_suggestion_output = self._parse_output(
            suggestion_scores_dict, suggested_freshness_thresholds
        )

        return freshness_suggestion_output

    @staticmethod
    def _convert_dates_to_utc(df: pd.DataFrame) -> pd.DataFrame:
        for col_name in df.columns:
            if df[col_name].dt.tz is None:
                # Assume that it's already in UTC
                df[col_name] = df[col_name].dt.tz_localize("UTC")
            else:
                # Convert date to UTC
                df[col_name] = df[col_name].dt.tz_convert("UTC")
        return df

    @staticmethod
    def _prune_null_columns(df: pd.DataFrame, not_null_score_col: str) -> pd.DataFrame:
        # Handle null columns
        df_pruned = df[df[not_null_score_col] > 0.999]
        if not df_pruned.empty:
            return df_pruned
        else:
            return df

    def _prune_future_dates(self, df: pd.DataFrame, last_date_score_col: str) -> pd.DataFrame:
        df_pruned = df[df[last_date_score_col] <= 0]
        if not df_pruned.empty:
            return df_pruned
        else:
            return df

    @staticmethod
    def _compute_final_weighted_score(df: pd.DataFrame, weights_dict: dict) -> pd.Series:
        _df = df.copy()
        for heuristic, weight in weights_dict.items():
            max_heuristic_ranking = _df[heuristic].max()
            _df[heuristic] = _df[heuristic] * weight / max_heuristic_ranking
        return _df.sum(axis=1)

    def _get_freshness_threshold(self, df: pd.DataFrame) -> dict[str, FreshnessTimeThreshold]:
        freshness_thresholds_dict = {}

        for col in df.columns:
            series = df[col].sort_values()
            if series.isnull().any():
                continue
            # Compute t(n) - t(n-1)
            series_diff = series.diff().dt.total_seconds()
            mean = series_diff.mean()
            std = series_diff.std()
            threshold_seconds = int(mean + 3 * std)
            threshold_seconds = max(1, threshold_seconds)  # TODO: aling min freshness interval
            soda_cl_threshold_str = self._convert_seconds_to_soda_cl_freshness(threshold_seconds)
            freshness_thresholds_dict[col] = FreshnessTimeThreshold(
                threshold_seconds=threshold_seconds,
                soda_cl_threshold_str=soda_cl_threshold_str,
            )

        return freshness_thresholds_dict

    @staticmethod
    def _convert_seconds_to_soda_cl_freshness(seconds: int) -> str:
        # convert seconds to hours and minutes
        minutes = seconds // 60
        seconds %= 60
        if minutes >= 60:
            hours = minutes // 60
            minutes %= 60
            if hours >= 24:
                days = hours // 24
                hours %= 24
                if hours >= 12:
                    days += 1
                return f"{days}d"
            else:
                if minutes >= 30:
                    hours += 1
                return f"{hours}h"
        elif minutes < 60 and minutes > 0:
            return f"{minutes}m"
        else:
            return "1m"

    @staticmethod
    def _parse_output(
        scores: dict, suggested_freshness_thresholds: dict
    ) -> FreshnessSuggestionOutput:
        freshness_suggestion_output = []
        for col_name, scores in scores.items():
            freshness_col_output = FreshnessColumnOutput(
                col_name=col_name,
                heuristic_scores=FreshnessHeuristics(**scores),
                threshold=suggested_freshness_thresholds[col_name],
                rank=scores["rank"],
            )
            freshness_suggestion_output.append(freshness_col_output)
        return FreshnessSuggestionOutput(freshness_attributes=freshness_suggestion_output)
