from __future__ import annotations

import datetime
import os
from typing import Any

import segment.analytics as analytics


class EventTracker:
    """Handles Event Tracking. Now done via segment."""

    def __init__(self, soda_api_key_id: str, invocation_id: str, adaptor_type: str):
        self.api_write_key = "8Rr6Dy40zqKe7WX3NdhiNpAxUWrduMcO"
        self.soda_api_key_id = soda_api_key_id
        self.invocation_id = invocation_id
        self.adaptor_type = adaptor_type
        self.push_event = True if os.getenv("PUSH_TRACKING", "t") == "t" else False
        self.env = os.getenv("ENV", "prod")

    def send_tracking_event(
        self,
        event_name: str,
        step_name: str,
        user_choice: bool | None = None,
        event_json: dict[str, Any] | None = None,
    ):
        if self.api_write_key:
            tracking_event_payload = {
                "invocation_id": self.invocation_id,
                "soda_api_key_id": self.soda_api_key_id,
                "event_name": event_name,
                "step_name": step_name,
                "user_choice": user_choice,
                "event_json": event_json,
                "adaptor_name": self.adaptor_type,
            }

            analytics.write_key = self.api_write_key
            if self.push_event:
                analytics.track(
                    f"soda-check-suggestion-{self.env}",
                    # TODO: document the need to set env != prod when testing to allow triage of events
                    # I think soda-core has some practices on this for OT we should check with them on how to
                    # make it somewhat foolproof (if at all possible)
                    "Soda Suggestion Usage",  # TODO: Change to Soda Suggestion CLI when stable
                    properties=tracking_event_payload,
                    timestamp=datetime.datetime.now(),
                )
                # NOTE: We're not calling analytics.flush() since the tracker is async
                # we will force flush at the end of the flow or during a user interrupt
