from __future__ import annotations

import questionary as q

from soda.generator.global_vars import (
    PREVIOUS_STEP_MESSAGE,
    QUESTIONARY_CHECKBOX_INSTRUCTION_WITH_GO_BACK,
    SKIPPED_STEP_MESSAGE,
)
from soda.generator.models.config_models import DuplicateValueCheckConfigs
from soda.generator.steps.base_suggestion import BaseSuggestion
from soda.generator.tracking.segment import EventTracker
from soda.generator.utils import (
    get_previous_step_key_binding,
    parse_sodacl_jinja_template,
    print_warning_panel,
)


class DuplicateValueCheckSuggestion(BaseSuggestion):
    def __init__(self, event_tracker: EventTracker, dataset_name: str, column_names: list[str]) -> None:
        super().__init__(event_tracker=event_tracker, dataset_name=dataset_name)
        self.column_names = column_names

    @property
    def suggestion_name(self):
        return "duplicate_value"

    @property
    def default_event_name(self):
        return "add_duplicate_value_check"

    def set_config(self):
        config_dict = self.get_config_dict(section="duplicate_value_check")
        config = DuplicateValueCheckConfigs(**config_dict)
        return config

    def ask(self):
        self.print_header()
        if not self.column_names:
            print_warning_panel(self.config.na_message)
            return SKIPPED_STEP_MESSAGE

        duplicate_check_columns = self._get_duplicate_value_check_decision()

        if duplicate_check_columns == PREVIOUS_STEP_MESSAGE:
            self.track_suggestion(event_name=PREVIOUS_STEP_MESSAGE, user_choice=True)
            return duplicate_check_columns
        sodacl_str = ""
        for i, column_name in enumerate(duplicate_check_columns):
            sodacl_str += parse_sodacl_jinja_template(
                "duplicate_check.yaml", column_name=column_name, sign="=", threshold=0
            )
            if i < len(duplicate_check_columns) - 1:
                sodacl_str += "\n"
        self.set_soda_cl(soda_cl=sodacl_str)
        n_duplicate_checks = len(duplicate_check_columns)
        user_choice = True if n_duplicate_checks > 0 else False
        self.track_suggestion(user_choice=user_choice, n_accepted_checks=n_duplicate_checks)

    def _get_duplicate_value_check_decision(self) -> list[str] | str:
        instruction = self.config.instruction.format(dataset_name=self.dataset_name)
        duplicate_check_columns: list[str] | str = q.checkbox(
            message=instruction,
            choices=self.column_names.copy(),
            style=self.custom_q_style,
            instruction=QUESTIONARY_CHECKBOX_INSTRUCTION_WITH_GO_BACK,
            custom_key_binding=get_previous_step_key_binding(),
        ).unsafe_ask()
        return duplicate_check_columns
