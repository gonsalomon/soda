from __future__ import annotations

import questionary as q

from soda.generator.global_vars import (
    PREVIOUS_STEP_MESSAGE,
    QUESTIONARY_SELECT_INSTRUCTION_WITH_GO_BACK,
)
from soda.generator.models.config_models import SchemaCheckConfigs
from soda.generator.steps.base_suggestion import BaseSuggestion
from soda.generator.tracking.segment import EventTracker
from soda.generator.utils import (
    get_previous_step_key_binding,
    parse_sodacl_jinja_template,
)


class SchemaCheckSuggestion(BaseSuggestion):
    def __init__(self, event_tracker: EventTracker, dataset_name: str) -> None:
        super().__init__(event_tracker=event_tracker, dataset_name=dataset_name)

    @property
    def suggestion_name(self):
        return "schema_check"

    @property
    def default_event_name(self):
        return "add_schema_check"

    def set_config(self):
        config_dict = self.get_config_dict(section="schema_check")
        config = SchemaCheckConfigs(**config_dict)
        return config

    def ask(self):
        self.print_header()
        choices = {answer: i for i, answer in enumerate(self.config.answers)}
        schema_check_decision = self._get_decision(choices=choices)
        if schema_check_decision == PREVIOUS_STEP_MESSAGE:
            self.track_suggestion(event_name=PREVIOUS_STEP_MESSAGE, user_choice=False)
            return schema_check_decision

        sodacl_str = ""
        if choices[schema_check_decision] == 0:
            sodacl_str = parse_sodacl_jinja_template("schema_check.yaml", alert_type="fail")
        elif choices[schema_check_decision] == 1:
            sodacl_str = parse_sodacl_jinja_template("schema_check.yaml", alert_type="warn")

        self.track_suggestion(
            user_choice=False if schema_check_decision == "No" else True,
            n_accepted_checks=0 if schema_check_decision == "No" else 1,
            event_json={"decision": schema_check_decision},
        )
        self.set_soda_cl(soda_cl=sodacl_str)

    def _get_decision(self, choices: dict[str, int]) -> str:
        choices_keys: list[str] = list(choices.keys())
        instruction = self.config.instruction.format(dataset_name=self.dataset_name)
        schema_check_decision: str = q.select(
            message=instruction,
            choices=choices_keys,
            style=self.custom_q_style,
            instruction=QUESTIONARY_SELECT_INSTRUCTION_WITH_GO_BACK,
            custom_key_binding=get_previous_step_key_binding(),
        ).unsafe_ask()
        return schema_check_decision
