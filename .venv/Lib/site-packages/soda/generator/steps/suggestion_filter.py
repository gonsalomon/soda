from __future__ import annotations

import questionary as q

from soda.generator.global_vars import QUESTIONARY_CHECKBOX_INSTRUCTION
from soda.generator.models.config_models import SuggestionFilterConfigs
from soda.generator.steps.base_suggestion import BaseSuggestion
from soda.generator.tracking.segment import EventTracker
from soda.generator.utils import print_warning_panel

__SPLITTER__ = " - "


class SuggestionFilter(BaseSuggestion):
    def __init__(self, event_tracker: EventTracker, dataset_name: str) -> None:
        super().__init__(event_tracker=event_tracker, dataset_name=dataset_name)

    @property
    def suggestion_name(self) -> str:
        return "suggestion_filter"

    @property
    def default_event_name(self) -> str:
        return "suggestion_filtering"

    def set_config(self):
        config_dict = self.get_config_dict(section="suggestion_filter")
        config = SuggestionFilterConfigs(**config_dict)
        return config

    def ask(self):
        self.print_header()

        check_key_name_mapping = {list(answer.keys())[0]: list(answer.values())[0] for answer in self.config.answers}
        instruction = self.config.instruction.format(dataset_name=self.dataset_name)
        choices = self._get_choices(check_key_name_mapping=check_key_name_mapping)
        selected_suggestions = q.checkbox(
            message=instruction,
            choices=choices,
            style=self.custom_q_style,
            instruction=QUESTIONARY_CHECKBOX_INSTRUCTION,
        ).unsafe_ask()

        check_name_key_mapping = {v: k for k, v in check_key_name_mapping.items()}
        mapped_suggestions = [
            check_name_key_mapping[selected_suggestion.split(__SPLITTER__)[0]]
            for selected_suggestion in selected_suggestions
        ]
        event_json = {"selected_suggestions": mapped_suggestions}
        if not mapped_suggestions:
            print_warning_panel(message=self.config.na_message)
            self.track_suggestion(event_json=event_json, user_choice=False)
        else:
            self.track_suggestion(event_json=event_json, user_choice=True)
        return mapped_suggestions

    def _get_choices(self, check_key_name_mapping: dict[str, str]):
        options = []

        for check_key, check_name in check_key_name_mapping.items():
            check_cfg = self.get_config_dict(section=check_key)
            doc_url = check_cfg["doc_url"]
            options.append(
                q.Choice(
                    title=[
                        ("class:check_name", check_name),
                        ("class:text", __SPLITTER__),
                        ("class:doc_url", doc_url),
                    ]
                )
            )
        return options
