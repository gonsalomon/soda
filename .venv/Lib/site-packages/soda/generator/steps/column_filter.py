from __future__ import annotations

import questionary as q

from soda.generator.global_vars import QUESTIONARY_CHECKBOX_INSTRUCTION
from soda.generator.models.config_models import ColumnFilterConfigs
from soda.generator.steps.base_suggestion import BaseSuggestion
from soda.generator.tracking.segment import EventTracker
from soda.generator.utils import print_info_panel, print_warning_panel


class ColumnFilter(BaseSuggestion):
    def __init__(
        self,
        event_tracker: EventTracker,
        dataset_name: str,
        column_names: list[str],
        column_based_selected_suggestions: list[str],
    ) -> None:
        super().__init__(event_tracker=event_tracker, dataset_name=dataset_name)
        self.column_names = column_names
        self.column_based_selected_suggestions = column_based_selected_suggestions

    @property
    def suggestion_name(self) -> str:
        return "column_filter"

    @property
    def default_event_name(self) -> str:
        return "columns_filtering"

    def set_config(self):
        config_dict = self.get_config_dict(section="column_filter")
        config = ColumnFilterConfigs(**config_dict)
        return config

    def ask(self) -> list[str]:
        n_cols = len(self.column_names)
        chunk_size = self.config.column_filter_threshold
        if n_cols < chunk_size:
            return self.column_names
        check_names = " and ".join(self.column_based_selected_suggestions)
        self.print_header()
        print_info_panel(
            self.config.panel_info_message.format(
                n_cols=n_cols, dataset_name=self.dataset_name, check_names=check_names
            )
        )

        n_pages = (n_cols // chunk_size) + 1

        filtered_columns = []

        current_page = 0

        # Iterate over column chunks of 5
        for i in range(0, n_cols, chunk_size):
            end = i + chunk_size
            current_page += 1
            if end > n_cols:
                end = n_cols
            filtered_columns.extend(
                q.checkbox(
                    self.config.instruction.format(current_page=current_page, n_pages=n_pages),
                    choices=self.column_names[i:end],
                    style=self.custom_q_style,
                    instruction=QUESTIONARY_CHECKBOX_INSTRUCTION,
                ).unsafe_ask()
            )
        if filtered_columns:
            print_info_panel(
                self.config.output_info_message.format(filtered_columns=filtered_columns, check_names=check_names)
            )
        else:
            print_warning_panel(self.config.na_message.format(check_names=check_names))
        self.track_suggestion(
            user_choice=True if filtered_columns else False,
            event_json={"number_chosen_columns": len(filtered_columns)},
        )
        return filtered_columns
