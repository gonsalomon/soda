from __future__ import annotations

import questionary as q

from soda.generator.global_vars import (
    PREVIOUS_STEP_MESSAGE,
    QUESTIONARY_CHECKBOX_INSTRUCTION_WITH_GO_BACK,
    SKIPPED_STEP_MESSAGE,
)
from soda.generator.models.config_models import ValidityCheckConfigs
from soda.generator.steps.base_suggestion import BaseSuggestion
from soda.generator.tracking.segment import EventTracker
from soda.generator.utils import (
    get_previous_step_key_binding,
    parse_sodacl_jinja_template,
    print_warning_panel,
)


class ValidityCheckSuggestion(BaseSuggestion):
    def __init__(
        self, event_tracker: EventTracker, dataset_name: str, potential_validity_checks: list[tuple[str, str]]
    ) -> None:
        super().__init__(event_tracker=event_tracker, dataset_name=dataset_name)
        self.potential_validity_checks = potential_validity_checks

    @property
    def suggestion_name(self) -> str:
        return "validity_check"

    @property
    def default_event_name(self) -> str:
        return "add_validity_check"

    def set_config(self):
        config_dict = self.get_config_dict(section="validity_check")
        config = ValidityCheckConfigs(**config_dict)
        return config

    def ask(self):
        self.print_header()
        if not self.potential_validity_checks:
            print_warning_panel(self.config.na_message.format(dataset_name=self.dataset_name))
            return SKIPPED_STEP_MESSAGE

        soda_cl_choice_map = {}
        for column_name, semantic_dtype in self.potential_validity_checks:
            soda_cl = parse_sodacl_jinja_template(
                "validity_check.yaml", column_name=column_name, semantic_type=semantic_dtype
            )
            choice_str = self.config.answer_template.format(column_name=column_name, semantic_dtype=semantic_dtype)
            soda_cl_choice_map[choice_str] = soda_cl

        selected_choices = self._get_validity_check_decision(soda_cl_choice_map=soda_cl_choice_map)
        if selected_choices == PREVIOUS_STEP_MESSAGE:
            self.track_suggestion(event_name=PREVIOUS_STEP_MESSAGE, user_choice=False)
            return selected_choices

        selected_sodacl = ""
        for i, choice in enumerate(selected_choices):
            selected_sodacl += soda_cl_choice_map[choice]
            if i < len(selected_choices) - 1:
                selected_sodacl += "\n"
        self.set_soda_cl(soda_cl=selected_sodacl)
        self.track_suggestion(
            user_choice=True if selected_choices else False,
            n_accepted_checks=len(selected_choices),
        )

    def _get_validity_check_decision(self, soda_cl_choice_map) -> list[str] | str:
        choices = list(soda_cl_choice_map.keys())
        instruction = self.config.instruction.format(dataset_name=self.dataset_name)
        validity_checks: list[str] | str = q.checkbox(
            message=instruction,
            choices=choices,
            style=self.custom_q_style,
            instruction=QUESTIONARY_CHECKBOX_INSTRUCTION_WITH_GO_BACK,
            custom_key_binding=get_previous_step_key_binding(),
        ).unsafe_ask()
        return validity_checks
