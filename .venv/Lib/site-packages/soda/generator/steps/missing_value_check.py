from __future__ import annotations

import questionary as q

from soda.generator.global_vars import (
    PREVIOUS_STEP_MESSAGE,
    QUESTIONARY_CHECKBOX_INSTRUCTION_WITH_GO_BACK,
    SKIPPED_STEP_MESSAGE,
)
from soda.generator.models.config_models import MissingValueCheckConfigs
from soda.generator.steps.base_suggestion import BaseSuggestion
from soda.generator.tracking.segment import EventTracker
from soda.generator.utils import (
    get_previous_step_key_binding,
    parse_sodacl_jinja_template,
    print_warning_panel,
)


class MissingValueCheckSuggestion(BaseSuggestion):
    def __init__(self, event_tracker: EventTracker, dataset_name: str, column_names: list[str]) -> None:
        super().__init__(event_tracker=event_tracker, dataset_name=dataset_name)
        self.column_names = column_names

    @property
    def suggestion_name(self) -> str:
        return "missing_value"

    @property
    def default_event_name(self) -> str:
        return "add_missing_value_check"

    def set_config(self):
        config_dict = self.get_config_dict(section="missing_value_check")
        config = MissingValueCheckConfigs(**config_dict)
        return config

    def ask(self):
        self.print_header()
        if not self.column_names:
            print_warning_panel(self.config.na_message)
            return SKIPPED_STEP_MESSAGE
        missing_value_check_columns = self._get_missing_value_check_decision()

        if missing_value_check_columns == PREVIOUS_STEP_MESSAGE:
            self.track_suggestion(event_name=PREVIOUS_STEP_MESSAGE, user_choice=False)
            return missing_value_check_columns

        sodacl_str = ""
        n_missing_value_checks = len(missing_value_check_columns)

        for i, column in enumerate(missing_value_check_columns):
            sodacl_str += parse_sodacl_jinja_template(
                "missing_value_check.yaml", column_name=column, sign="=", threshold=0
            )
            if i < n_missing_value_checks - 1:
                sodacl_str += "\n"
        self.set_soda_cl(soda_cl=sodacl_str)
        self.track_suggestion(
            user_choice=True if n_missing_value_checks > 0 else False,
            n_accepted_checks=n_missing_value_checks,
        )

    def _get_missing_value_check_decision(self) -> list[str] | str:
        instruction = self.config.instruction.format(dataset_name=self.dataset_name)
        missing_value_check_columns: list[str] | str = q.checkbox(
            message=instruction,
            choices=self.column_names.copy(),
            style=self.custom_q_style,
            instruction=QUESTIONARY_CHECKBOX_INSTRUCTION_WITH_GO_BACK,
            custom_key_binding=get_previous_step_key_binding(),
        ).unsafe_ask()
        return missing_value_check_columns
