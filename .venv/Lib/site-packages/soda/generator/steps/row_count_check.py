from __future__ import annotations

import questionary as q

from soda.generator.global_vars import (
    PREVIOUS_STEP_MESSAGE,
    QUESTIONARY_CONFIRM_INSTRUCTION_WITH_GO_BACK,
)
from soda.generator.models.config_models import RowCountCheckConfigs
from soda.generator.steps.base_suggestion import BaseSuggestion
from soda.generator.tracking.segment import EventTracker
from soda.generator.utils import (
    get_previous_step_key_binding,
    parse_sodacl_jinja_template,
)


class RowCountCheckSuggestion(BaseSuggestion):
    def __init__(self, event_tracker: EventTracker, dataset_name: str) -> None:
        super().__init__(event_tracker=event_tracker, dataset_name=dataset_name)

    @property
    def suggestion_name(self) -> str:
        return "row_count"

    @property
    def default_event_name(self) -> str:
        return "add_row_count"

    def set_config(self):
        config_dict = self.get_config_dict(section="row_count")
        config = RowCountCheckConfigs(**config_dict)
        return config

    def ask(self):
        self.print_header()
        self._soda_cl = ""
        row_count_answer = self._ask_row_count_zero_check_step()
        if row_count_answer == PREVIOUS_STEP_MESSAGE:
            return PREVIOUS_STEP_MESSAGE

        row_count_anomaly_answer = self._ask_row_count_anomaly_detection_step()
        if row_count_anomaly_answer == PREVIOUS_STEP_MESSAGE:
            return PREVIOUS_STEP_MESSAGE
        self.set_soda_cl(self._soda_cl)

    def _ask_row_count_zero_check_step(self):
        row_count_decision = self._get_row_count_zero_check_decision()
        if row_count_decision == PREVIOUS_STEP_MESSAGE:
            return row_count_decision

        self.track_suggestion(
            event_name="add_row_count",
            user_choice=row_count_decision,
            n_accepted_checks=1 if row_count_decision else 0,
        )
        if row_count_decision:
            sodacl_row_count = parse_sodacl_jinja_template("row_count.yaml") + "\n"
            self._soda_cl += sodacl_row_count

    def _ask_row_count_anomaly_detection_step(self):
        anomaly_row_count_decision = self._get_row_count_anomaly_detection_decision()
        if anomaly_row_count_decision == PREVIOUS_STEP_MESSAGE:
            self.track_suggestion(event_name=PREVIOUS_STEP_MESSAGE, user_choice=False)
            return anomaly_row_count_decision
        self.track_suggestion(
            event_name="add_row_count_anomaly_check",
            user_choice=anomaly_row_count_decision,
            n_accepted_checks=1 if anomaly_row_count_decision else 0,
        )
        if anomaly_row_count_decision:
            sodacl_row_count_anom_detection = parse_sodacl_jinja_template("row_count_anomaly_detection.yaml")
            self._soda_cl += sodacl_row_count_anom_detection

    def _get_row_count_zero_check_decision(self) -> bool | str:
        instruction = self.config.instruction.format(dataset_name=self.dataset_name)
        row_count_decision: bool | str = q.confirm(
            instruction,
            style=self.custom_q_style,
            custom_key_binding=get_previous_step_key_binding(),
            instruction=QUESTIONARY_CONFIRM_INSTRUCTION_WITH_GO_BACK,
        ).unsafe_ask()
        return row_count_decision

    def _get_row_count_anomaly_detection_decision(self) -> bool | str:
        # Then ask if user wants to add row count anomaly detection
        instruction = self.config.instruction_2.format(dataset_name=self.dataset_name)
        anomaly_row_count_decision: bool | str = q.confirm(
            instruction,
            style=self.custom_q_style,
            custom_key_binding=get_previous_step_key_binding(),
            instruction=QUESTIONARY_CONFIRM_INSTRUCTION_WITH_GO_BACK,
        ).unsafe_ask()
        return anomaly_row_count_decision
