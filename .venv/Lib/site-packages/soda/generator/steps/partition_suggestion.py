from __future__ import annotations

import re

import questionary as q

from soda.generator.global_vars import (
    PREVIOUS_STEP_MESSAGE,
    QUESTIONARY_SELECT_INSTRUCTION_WITH_GO_BACK,
    QUESTIONARY_TEXT_INSTRUCTION_WITH_GO_BACK,
    SKIPPED_STEP_MESSAGE,
)
from soda.generator.models.config_models import PartitionConfigs
from soda.generator.steps.base_suggestion import BaseSuggestion
from soda.generator.tracking.segment import EventTracker
from soda.generator.utils import get_previous_step_key_binding, print_warning_panel


class PartitionSuggestion(BaseSuggestion):
    def __init__(
        self,
        event_tracker: EventTracker,
        dataset_name: str,
        freshness_suggestion: list[tuple[str, str]],
    ) -> None:
        super().__init__(event_tracker=event_tracker, dataset_name=dataset_name)
        self.freshness_suggestion = freshness_suggestion
        self.partition_column: str | None = None
        self.n_days_to_partition_by: str | None = None

    @property
    def suggestion_name(self) -> str:
        return "dataset_partition"

    @property
    def default_event_name(self) -> str:
        return "add_partitioning"

    def set_config(self):
        config_dict = self.get_config_dict(section="partition")
        config = PartitionConfigs(**config_dict)
        return config

    def ask(self):
        self.print_header()
        partition_answer = self._ask_partition_step()
        if partition_answer == PREVIOUS_STEP_MESSAGE or partition_answer == SKIPPED_STEP_MESSAGE:
            return partition_answer
        if self.partition_column is None:
            return

        n_days_answer = self._ask_number_of_days_to_partition_by_step()
        if n_days_answer == PREVIOUS_STEP_MESSAGE:
            return PREVIOUS_STEP_MESSAGE

    def _ask_partition_step(self):
        partition_column_candidates = [column for column, _ in self.freshness_suggestion]
        partition_column = self._get_partition_column_decision(partition_column_candidates=partition_column_candidates)

        if partition_column == PREVIOUS_STEP_MESSAGE:
            self.track_suggestion(event_name=PREVIOUS_STEP_MESSAGE, user_choice=False)
            return partition_column

        if partition_column == self.config.skip_message:
            self.track_suggestion(user_choice=False)
            return

        if partition_column == SKIPPED_STEP_MESSAGE:
            return SKIPPED_STEP_MESSAGE

        chosen_column_index = partition_column_candidates.index(partition_column)
        self.track_suggestion(
            user_choice=True,
            event_json={
                "selected_top_column": True if chosen_column_index == 1 else False,
                "column_choice_index": chosen_column_index,
                "chosen_column": partition_column,
            },
        )
        self.partition_column = partition_column

    def _ask_number_of_days_to_partition_by_step(self):
        n_days_to_partition_by = self._get_n_days_to_partition_by_decision()
        if n_days_to_partition_by == PREVIOUS_STEP_MESSAGE:
            self.track_suggestion(event_name=PREVIOUS_STEP_MESSAGE, user_choice=False)
            return n_days_to_partition_by

        self.n_days_to_partition_by = n_days_to_partition_by
        self.track_suggestion(
            event_name="add_number_of_days_to_partition",
            user_choice=True,
            event_json={
                "chosen_column": self.partition_column,
                "number_of_days_to_partition": self.n_days_to_partition_by,
            },
        )

    def _get_partition_column_decision(self, partition_column_candidates: list[str | q.Choice]) -> str:
        if not partition_column_candidates:
            # It means that there is no candidate column to check freshness
            print_warning_panel(self.config.na_message.format(dataset_name=self.dataset_name))
            return SKIPPED_STEP_MESSAGE
        # add no partition option to beginning of list
        partition_column_candidates.insert(0, q.Choice(title=[("class:skip_question", self.config.skip_message)]))
        instruction = self.config.instruction.format(dataset_name=self.dataset_name)
        partition_column: str = q.select(
            message=instruction,
            choices=partition_column_candidates,
            style=self.custom_q_style,
            instruction=QUESTIONARY_SELECT_INSTRUCTION_WITH_GO_BACK,
            custom_key_binding=get_previous_step_key_binding(),
        ).unsafe_ask()
        return partition_column

    def _get_n_days_to_partition_by_decision(self) -> str:
        n_days_to_partition_by: str = q.text(
            message=self.config.instruction_2,
            default=str(1),
            validate=lambda x: re.match(r"^[1-9][0-9]*$", x) is not None,
            style=self.custom_q_style,
            instruction=QUESTIONARY_TEXT_INSTRUCTION_WITH_GO_BACK,
            custom_key_binding=get_previous_step_key_binding(),
        ).unsafe_ask()
        return n_days_to_partition_by
